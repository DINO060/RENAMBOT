#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio
import os
import time
import math
import re
import uuid
import shutil
import json
from datetime import datetime, timedelta
from collections import defaultdict
from telethon import TelegramClient, events, Button
from telethon.tl.types import DocumentAttributeFilename, DocumentAttributeVideo
from telethon.errors import FloodWaitError
from telethon.tl.functions.messages import SetTypingRequest
from telethon.tl.types import SendMessageTypingAction, SendMessageUploadDocumentAction
import logging

# Import de la configuration

API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
TOKEN = os.getenv("TOKEN")
ADMIN_IDS = os.getenv("ADMIN_IDS")

# Configuration
MAX_FILE_SIZE = 2000 * 1024 * 1024  # 2 GB
TEMP_DIR = "temp_files"
THUMBNAIL_DIR = "thumbnails"
USER_TIMEOUT = 600  # 10 minutes
PROGRESS_UPDATE_INTERVAL = 5  # secondes
MAX_THUMB_SIZE = 200 * 1024  # 200 KB

# Nouvelles limites
DAILY_LIMIT_GB = 1  # 1 GB par jour par utilisateur
DAILY_LIMIT_BYTES = DAILY_LIMIT_GB * 1024 * 1024 * 1024
COOLDOWN_SECONDS = 30  # 30 secondes entre les fichiers

# Configuration du logging
logging.basicConfig(
    format='[%(levelname) 5s/%(asctime)s] %(name)s: %(message)s',
    level=logging.INFO
)

# Dictionnaire pour stocker les sessions utilisateur
user_sessions = {}

# Syst√®me de limites d'utilisation
user_usage = defaultdict(lambda: {'daily_bytes': 0, 'last_reset': None, 'last_file_time': None})
usage_file = "user_usage.json"

# Syst√®me de pr√©f√©rences utilisateur
sessions = {}  # Pour stocker les pr√©f√©rences utilisateur

DEFAULT_USERNAME = "@dino_renamebot"  # Mets ici ton vrai username

def clean_filename_text(text):
    """Nettoie le texte en supprimant tous les @username et hashtags"""
    if not text:
        return text
    # Supprimer tous les formats de @username
    text = re.sub(r'[\[\(\{]?@\w+[\]\)\}]?', '', text, flags=re.IGNORECASE)
    # Supprimer les hashtags
    text = re.sub(r'#\w+', '', text, flags=re.IGNORECASE)
    # Supprimer les espaces multiples
    text = re.sub(r'\s+', ' ', text)
    return text.strip()

def add_custom_text_to_filename(filename, custom_text=None, position='end'):
    """Ajoute un texte personnalis√© au nom du fichier"""
    if not custom_text:
        return filename
    
    name, ext = os.path.splitext(filename)
    
    # Nettoyer d'abord le nom existant
    name = clean_filename_text(name)
    
    # Ajouter le texte personnalis√©
    if position == 'end':
        name = f"{name} {custom_text}"
    else:  # start
        name = f"{custom_text} {name}"
    
    # Nettoyer les espaces multiples
    name = re.sub(r'\s+', ' ', name).strip()
    
    return f"{name}{ext}"

def add_default_username_to_filename(filename, username, position='end'):
    name, ext = os.path.splitext(filename)
    # √âvite de l‚Äôajouter plusieurs fois
    if username.lower() in name.lower():
        return filename
    if position == 'end':
        name = f"{name} {username}"
    else:
        name = f"{username} {name}"
    name = re.sub(r'\s+', ' ', name).strip()
    return f"{name}{ext}"

def save_user_preferences():
    """Sauvegarde les pr√©f√©rences utilisateur"""
    try:
        prefs = {}
        for user_id, session in sessions.items():
            if 'custom_text' in session or 'text_position' in session or 'clean_tags' in session:
                prefs[str(user_id)] = {
                    'custom_text': session.get('custom_text', ''),
                    'text_position': session.get('text_position', 'end'),
                    'clean_tags': session.get('clean_tags', True)
                }
        
        with open('user_preferences.json', 'w') as f:
            json.dump(prefs, f, indent=2)
    except Exception as e:
        logging.error(f"Erreur sauvegarde pr√©f√©rences: {e}")

def load_user_preferences():
    """Charge les pr√©f√©rences utilisateur"""
    try:
        if os.path.exists('user_preferences.json'):
            with open('user_preferences.json', 'r') as f:
                prefs = json.load(f)
                for user_id_str, pref_data in prefs.items():
                    user_id = int(user_id_str)
                    sessions[user_id] = pref_data
    except Exception as e:
        logging.error(f"Erreur chargement pr√©f√©rences: {e}")

# Cr√©er le dossier temporaire
os.makedirs(TEMP_DIR, exist_ok=True)
os.makedirs(THUMBNAIL_DIR, exist_ok=True)

# Initialiser le client Telethon
bot = TelegramClient('rename_bot', API_ID, API_HASH).start(bot_token=TOKEN)

def load_user_usage():
    """Charge les donn√©es d'utilisation depuis le fichier"""
    try:
        if os.path.exists(usage_file):
            with open(usage_file, 'r') as f:
                data = json.load(f)
                for user_id_str, usage_data in data.items():
                    user_id = int(user_id_str)
                    user_usage[user_id] = usage_data
    except Exception as e:
        logging.error(f"Erreur chargement usage: {e}")

def save_user_usage():
    """Sauvegarde les donn√©es d'utilisation dans le fichier"""
    try:
        data = {}
        for user_id, usage_data in user_usage.items():
            data[str(user_id)] = usage_data
        with open(usage_file, 'w') as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        logging.error(f"Erreur sauvegarde usage: {e}")

def reset_daily_usage_if_needed(user_id):
    """R√©initialise l'utilisation quotidienne si n√©cessaire"""
    now = datetime.now()
    last_reset = user_usage[user_id].get('last_reset')
    
    if last_reset:
        last_reset = datetime.fromisoformat(last_reset)
        if now.date() > last_reset.date():
            user_usage[user_id]['daily_bytes'] = 0
            user_usage[user_id]['last_reset'] = now.isoformat()
            logging.info(f"Reset quotidien pour user {user_id}")
    else:
        user_usage[user_id]['last_reset'] = now.isoformat()

def check_user_limits(user_id, file_size):
    """V√©rifie les limites de l'utilisateur"""
    reset_daily_usage_if_needed(user_id)
    
    # V√©rifier la limite quotidienne
    current_daily = user_usage[user_id]['daily_bytes']
    if current_daily + file_size > DAILY_LIMIT_BYTES:
        remaining = DAILY_LIMIT_BYTES - current_daily
        return False, f"Limite quotidienne atteinte! Utilis√©: {human_readable_size(current_daily)}/{human_readable_size(DAILY_LIMIT_BYTES)}. Restant: {human_readable_size(remaining)}"
    
    # V√©rifier le d√©lai entre les fichiers
    last_file_time = user_usage[user_id].get('last_file_time')
    if last_file_time:
        last_file_time = datetime.fromisoformat(last_file_time)
        time_since_last = (datetime.now() - last_file_time).total_seconds()
        if time_since_last < COOLDOWN_SECONDS:
            remaining_cooldown = COOLDOWN_SECONDS - time_since_last
            return False, f"Attendez {int(remaining_cooldown)} secondes avant le prochain fichier"
    
    return True, "OK"

def update_user_usage(user_id, file_size):
    """Met √† jour l'utilisation de l'utilisateur"""
    user_usage[user_id]['daily_bytes'] += file_size
    user_usage[user_id]['last_file_time'] = datetime.now().isoformat()
    save_user_usage()

def get_user_usage_info(user_id):
    """Retourne les informations d'utilisation de l'utilisateur"""
    reset_daily_usage_if_needed(user_id)
    daily_used = user_usage[user_id]['daily_bytes']
    daily_remaining = DAILY_LIMIT_BYTES - daily_used
    
    return {
        'daily_used': daily_used,
        'daily_remaining': daily_remaining,
        'daily_limit': DAILY_LIMIT_BYTES,
        'percentage': (daily_used / DAILY_LIMIT_BYTES) * 100
    }

async def cleanup_user_files(user_id):
    """Nettoie tous les fichiers d'un utilisateur (sauf thumbnails)"""
    try:
        # Supprimer les fichiers temporaires de l'utilisateur
        for filename in os.listdir(TEMP_DIR):
            if filename.startswith(f"{user_id}_"):
                filepath = os.path.join(TEMP_DIR, filename)
                try:
                    if os.path.isfile(filepath):
                        os.remove(filepath)
                        logging.info(f"Fichier utilisateur supprim√©: {filename}")
                except Exception as e:
                    logging.error(f"Erreur suppression fichier {filename}: {e}")
        
        # Nettoyer les sessions
        if user_id in user_sessions:
            if 'temp_path' in user_sessions[user_id]:
                try:
                    os.remove(user_sessions[user_id]['temp_path'])
                except:
                    pass
            del user_sessions[user_id]
            
        logging.info(f"Nettoyage complet effectu√© pour user {user_id}")
        return True
    except Exception as e:
        logging.error(f"Erreur nettoyage user {user_id}: {e}")
        return False

async def auto_cleanup_task():
    """T√¢che de nettoyage automatique qui s'ex√©cute toutes les heures"""
    while True:
        try:
            await asyncio.sleep(3600)  # 1 heure
            
            # Nettoyer les sessions expir√©es
            await clean_old_sessions()
            
            # Nettoyer les fichiers orphelins
            current_time = time.time()
            for filename in os.listdir(TEMP_DIR):
                filepath = os.path.join(TEMP_DIR, filename)
                if os.path.isfile(filepath):
                    file_age = current_time - os.path.getmtime(filepath)
                    if file_age > 3600:  # Plus d'1 heure
                        try:
                            os.remove(filepath)
                            logging.info(f"Fichier orphelin supprim√©: {filename}")
                        except Exception as e:
                            logging.error(f"Erreur suppression orphelin {filename}: {e}")
            
            logging.info("Nettoyage automatique effectu√©")
            
        except Exception as e:
            logging.error(f"Erreur nettoyage automatique: {e}")
            await asyncio.sleep(300)  # Attendre 5 minutes en cas d'erreur

def human_readable_size(size_bytes):
    """Convertit une taille en bytes en format lisible"""
    if size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return "{} {}".format(s, size_name[i])

def sanitize_filename(filename):
    """Nettoie le nom de fichier pour √©viter les probl√®mes"""
    # Supprimer les caract√®res interdits
    filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
    # Supprimer les espaces en d√©but/fin
    filename = filename.strip('. ')
    # Limiter la longueur
    name, ext = os.path.splitext(filename)
    if len(name) > 200:
        name = name[:200]
    return name + ext

def get_video_duration(file_path):
    """Obtenir la dur√©e d'une vid√©o avec ffprobe"""
    try:
        import subprocess
        import json
        
        # Si ffprobe n'est pas disponible, retourner None
        if not shutil.which("ffprobe"):
            return None
            
        result = subprocess.run(
            ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format', file_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        if result.returncode == 0:
            data = json.loads(result.stdout)
            duration = float(data.get('format', {}).get('duration', 0))
            return int(duration)
    except:
        pass
    return None

def get_video_dimensions(file_path):
    """Obtenir les dimensions d'une vid√©o avec ffprobe"""
    try:
        import subprocess
        import json
        
        if not shutil.which("ffprobe"):
            return None, None
            
        result = subprocess.run(
            ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', '-select_streams', 'v:0', file_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        if result.returncode == 0:
            data = json.loads(result.stdout)
            streams = data.get('streams', [])
            if streams:
                width = streams[0].get('width', 0)
                height = streams[0].get('height', 0)
                return width, height
    except:
        pass
    return None, None

async def progress_callback(current, total, event, start_time, progress_msg, action="Downloading", last_update_time=None):
    """Callback pour afficher la progression"""
    now = time.time()
    
    if last_update_time is not None:
        if now - last_update_time[0] < PROGRESS_UPDATE_INTERVAL:
            return
        last_update_time[0] = now
    
    diff = now - start_time
    
    # √âviter la division par z√©ro au tout d√©but
    if diff == 0:
        diff = 1

    percentage = current * 100 / total
    speed = current / diff
    time_to_completion = round((total - current) / speed) if speed > 0 else 0
    
    progress_bar_length = 10
    completed_length = int(percentage / 10)
    progress_bar = '‚ñì' * completed_length + '‚ñë' * (progress_bar_length - completed_length)
    
    text = """<b>{} File...</b>

<code>{}</code> {:.1f}%

üìä <b>Progress:</b> {} / {}
‚ö° <b>Speed:</b> {}/s
‚è± <b>ETA:</b> {}s
""".format(
        action,
        progress_bar,
        percentage,
        human_readable_size(current),
        human_readable_size(total),
        human_readable_size(speed),
        time_to_completion
    )
    
    try:
        await progress_msg.edit(text, parse_mode='html')
    except FloodWaitError as e:
        logging.warning(f"Rate limit hit in progress_callback. Sleeping for {e.seconds} seconds.")
        await asyncio.sleep(e.seconds)
    except Exception:
        # Ignorer les autres erreurs d'√©dition (par exemple, message non modifi√©)
        pass

async def clean_old_sessions():
    """Nettoie les sessions expir√©es"""
    current_time = datetime.now()
    expired_users = []
    
    for user_id, data in user_sessions.items():
        if current_time - data['timestamp'] > timedelta(seconds=USER_TIMEOUT):
            expired_users.append(user_id)
    
    for user_id in expired_users:
        if 'temp_path' in user_sessions[user_id]:
            try:
                os.remove(user_sessions[user_id]['temp_path'])
            except:
                pass
        del user_sessions[user_id]

@bot.on(events.NewMessage(pattern='/start'))
async def start_handler(event):
    """Handler am√©lior√© pour la commande /start"""
    user_id = event.sender_id
    
    # Charger les donn√©es si pas d√©j√† fait
    if not hasattr(start_handler, 'data_loaded'):
        load_user_usage()
        load_user_preferences()
        start_handler.data_loaded = True
    
    # Obtenir les informations d'utilisation
    usage_info = get_user_usage_info(user_id)
    
    # V√©rifier si l'utilisateur a un texte personnalis√©
    custom_text = sessions.get(user_id, {}).get('custom_text', '')
    
    welcome_text = """üëã <b>Welcome to Advanced File Rename Bot!</b>

Send me any file and I'll help you rename it.

<b>üìã Features:</b>
‚Ä¢ Support all file types (up to 2 GB)
‚Ä¢ Custom text/username addition
‚Ä¢ Fast thumbnail processing ‚ö°
‚Ä¢ Auto-cleanup of @tags and #hashtags
‚Ä¢ Video streaming support üé¨"""
    
    if custom_text:
        welcome_text += f"\n‚Ä¢ Custom text: <code>{custom_text}</code>"
    
    welcome_text += f"""

<b>üìä Your Daily Usage:</b>
‚Ä¢ Used: {human_readable_size(usage_info['daily_used'])} / {human_readable_size(usage_info['daily_limit'])} ({usage_info['percentage']:.1f}%)
‚Ä¢ Remaining: {human_readable_size(usage_info['daily_remaining'])}
‚Ä¢ Cooldown: 30 seconds between files

<b>üéØ Commands:</b>
/start - Show this message
/settings - Configure bot settings ‚öôÔ∏è
/usage - Check your usage limits
/setthumb - Set custom thumbnail
/delthumb - Delete custom thumbnail
/cancel - Cancel current operation

<b>üì§ Just send me a file to get started!</b>"""
    
    # Bouton Settings
    keyboard = [
        [Button.inline("‚öôÔ∏è Settings", "show_settings")]
    ]
    
    await event.reply(welcome_text, parse_mode='html', buttons=keyboard)

@bot.on(events.NewMessage(pattern='/cancel'))
async def cancel_handler(event):
    """Handler pour annuler l'op√©ration en cours"""
    user_id = event.sender_id
    
    if user_id in user_sessions:
        if 'temp_path' in user_sessions[user_id]:
            try:
                os.remove(user_sessions[user_id]['temp_path'])
            except:
                pass
        del user_sessions[user_id]
        await event.reply("‚ùå <b>Operation cancelled.</b>", parse_mode='html')
    else:
        await event.reply("‚ÑπÔ∏è No active operation to cancel.")

@bot.on(events.NewMessage(pattern='/status'))
async def status_handler(event):
    """Handler pour v√©rifier le statut du bot"""
    active_sessions = len(user_sessions)
    
    # V√©rifier l'espace disque (Windows compatible)
    if os.name == 'nt':  # Windows
        import shutil
        total, used, free = shutil.disk_usage(TEMP_DIR)
        free_space = free
    else:  # Linux/Mac
        stat = os.statvfs(TEMP_DIR)
        free_space = stat.f_bavail * stat.f_frsize
    
    # V√©rifier ffmpeg
    ffmpeg_status = "‚úÖ Available" if shutil.which("ffmpeg") else "‚ùå Not available"
    
    status_text = """ü§ñ <b>Bot Status</b>

‚úÖ <b>Status:</b> Online
üë• <b>Active Sessions:</b> {}
üíæ <b>Free Space:</b> {}
üìä <b>Max File Size:</b> {}
üé¨ <b>FFmpeg:</b> {}
üìà <b>Daily Limit:</b> {} per user
‚è± <b>Cooldown:</b> {} seconds

<i>Bot is running smoothly!</i>""".format(
        active_sessions,
        human_readable_size(free_space),
        human_readable_size(MAX_FILE_SIZE),
        ffmpeg_status,
        human_readable_size(DAILY_LIMIT_BYTES),
        COOLDOWN_SECONDS
    )
    
    await event.reply(status_text, parse_mode='html')

@bot.on(events.NewMessage(pattern='/usage'))
async def usage_handler(event):
    """Handler pour v√©rifier l'utilisation de l'utilisateur"""
    user_id = event.sender_id
    usage_info = get_user_usage_info(user_id)
    
    # Cr√©er une barre de progression
    progress_bar_length = 20
    completed_length = int((usage_info['percentage'] / 100) * progress_bar_length)
    progress_bar = '‚ñà' * completed_length + '‚ñë' * (progress_bar_length - completed_length)
    
    usage_text = """üìä <b>Your Usage Statistics</b>

<b>Daily Limit:</b> {}
<b>Used Today:</b> {} ({:.1f}%)
<b>Remaining:</b> {}

<code>{}</code>

<b>Next Reset:</b> Tomorrow at 00:00
<b>Cooldown:</b> {} seconds between files

<i>Keep track of your usage!</i>""".format(
        human_readable_size(usage_info['daily_limit']),
        human_readable_size(usage_info['daily_used']),
        usage_info['percentage'],
        human_readable_size(usage_info['daily_remaining']),
        progress_bar,
        COOLDOWN_SECONDS
    )
    
    await event.reply(usage_text, parse_mode='html')

@bot.on(events.NewMessage(pattern='/settings'))
async def settings_command(event):
    """Handler pour la commande /settings"""
    await show_settings_menu(event)

async def show_settings_menu(event):
    """Affiche le menu des param√®tres"""
    user_id = event.sender_id if hasattr(event, 'sender_id') else event.query.user_id
    
    # Charger les pr√©f√©rences si n√©cessaire
    if user_id not in sessions:
        sessions[user_id] = {}
    
    custom_text = sessions.get(user_id, {}).get('custom_text', '')
    text_position = sessions.get(user_id, {}).get('text_position', 'end')
    clean_tags = sessions.get(user_id, {}).get('clean_tags', True)
    custom_username = sessions.get(user_id, {}).get('custom_username', '')
    
    text = "‚öôÔ∏è <b>Bot Settings</b>\n\n"
    
    if custom_text:
        text += f"üìù Custom text: <code>{custom_text}</code>\n"
        text += f"üìç Position: {text_position}\n"
    else:
        text += "üìù No custom text set\n"
    if custom_username:
        text += f"üë§ Username: <code>{custom_username}</code>\n"
    
    text += f"üßπ Auto-clean tags: {'Yes' if clean_tags else 'No'}\n\n"
    text += "Choose an option:"
    
    keyboard = [
        [Button.inline("‚ûï Add/Edit Custom Text", "add_custom_text")],
        [Button.inline("üë§ Add/Edit Username", "add_custom_username")],
        [Button.inline("üìç Change Position", "change_text_position")],
        [Button.inline("üóëÔ∏è Remove Custom Text", "remove_custom_text")],
        [Button.inline("üßπ Toggle Clean Tags", "toggle_clean_tags")],
        [Button.inline("‚ùå Close", "close_settings")]
    ]
    
    if isinstance(event, events.NewMessage.Event):
        await event.reply(text, parse_mode='html', buttons=keyboard)
    else:
        await event.edit(text, parse_mode='html', buttons=keyboard)

@bot.on(events.NewMessage(pattern='/cleanup'))
async def cleanup_handler(event):
    """Handler pour nettoyer les fichiers de l'utilisateur (admin seulement)"""
    user_id = event.sender_id
    
    # V√©rifier si l'utilisateur est admin
    admin_list = [int(x) for x in str(ADMIN_IDS).split(',') if x.strip()] if ADMIN_IDS else []
    
    if user_id not in admin_list:
        await event.reply("‚ùå <b>Access denied.</b> This command is for administrators only.", parse_mode='html')
        return
    
    # Nettoyer les fichiers de l'utilisateur
    success = await cleanup_user_files(user_id)
    
    if success:
        await event.reply("‚úÖ <b>Cleanup completed!</b>\n\nAll user files have been cleaned (thumbnails preserved).", parse_mode='html')
    else:
        await event.reply("‚ùå <b>Cleanup failed.</b>\n\nSome files could not be deleted.", parse_mode='html')

@bot.on(events.NewMessage(pattern='/setthumb'))
async def setthumb_handler(event):
    """Handler pour d√©finir une miniature"""
    user_id = event.sender_id
    
    # Stocker que l'utilisateur veut d√©finir un thumbnail
    user_sessions[user_id] = {
        'action': 'set_thumbnail',
        'timestamp': datetime.now()
    }
    
    await event.reply(
        "üñºÔ∏è <b>Send me a photo to set as thumbnail</b>\n\n"
        "Requirements:\n"
        "‚Ä¢ Must be a photo (not document)\n"
        "‚Ä¢ Size limit: 200 KB\n"
        "‚Ä¢ Format: JPEG/PNG\n\n"
        "Send /cancel to abort.",
        parse_mode='html'
    )

@bot.on(events.NewMessage(pattern='/delthumb'))
async def delthumb_handler(event):
    """Handler pour supprimer la miniature"""
    user_id = event.sender_id
    thumb_path = os.path.join(THUMBNAIL_DIR, "{}.jpg".format(user_id))
    
    if os.path.exists(thumb_path):
        try:
            os.remove(thumb_path)
            await event.reply("‚úÖ <b>Thumbnail deleted successfully!</b>", parse_mode='html')
        except Exception as e:
            await event.reply("‚ùå <b>Error deleting thumbnail:</b> {}".format(str(e)), parse_mode='html')
    else:
        await event.reply("‚ùå <b>No thumbnail found to delete.</b>", parse_mode='html')

@bot.on(events.NewMessage(pattern='/showthumb'))
async def showthumb_handler(event):
    """Handler pour afficher la miniature actuelle"""
    user_id = event.sender_id
    thumb_path = os.path.join(THUMBNAIL_DIR, "{}.jpg".format(user_id))
    
    if os.path.exists(thumb_path):
        await event.reply(
            file=thumb_path,
            message="üñºÔ∏è <b>Your current thumbnail:</b>",
            parse_mode='html'
        )
    else:
        await event.reply("‚ùå <b>No thumbnail set.</b>\n\nUse /setthumb to set one.", parse_mode='html')

@bot.on(events.NewMessage(func=lambda e: e.photo))
async def photo_handler(event):
    """Handler pour les photos (thumbnails)"""
    user_id = event.sender_id
    
    # V√©rifier si l'utilisateur est en mode set_thumbnail
    if user_id in user_sessions and user_sessions[user_id].get('action') == 'set_thumbnail':
        # V√©rifier la taille
        if event.file.size > MAX_THUMB_SIZE:
            await event.reply(
                "‚ùå <b>Photo too large!</b>\n\n"
                "Maximum size: {}\n"
                "Your photo: {}".format(
                    human_readable_size(MAX_THUMB_SIZE),
                    human_readable_size(event.file.size)
                ),
                parse_mode='html'
            )
            del user_sessions[user_id]
            return
        
        # Sauvegarder la miniature
        thumb_path = os.path.join(THUMBNAIL_DIR, "{}.jpg".format(user_id))
        
        try:
            # Message de progression
            progress_msg = await event.reply("‚è≥ <b>Saving thumbnail...</b>", parse_mode='html')
            
            # T√©l√©charger la photo
            await event.download_media(file=thumb_path)
            
            # Confirmer
            await progress_msg.edit(
                "‚úÖ <b>Thumbnail saved successfully!</b>\n\n"
                "This thumbnail will be used for all your renamed files.\n"
                "Use /delthumb to remove it.",
                parse_mode='html'
            )
            
            # Nettoyer la session
            del user_sessions[user_id]
            
        except Exception as e:
            await progress_msg.edit(
                "‚ùå <b>Error saving thumbnail:</b> {}".format(str(e)),
                parse_mode='html'
            )
            if user_id in user_sessions:
                del user_sessions[user_id]

@bot.on(events.NewMessage(func=lambda e: e.file and not e.photo))
async def file_handler(event):
    """Handler principal pour les fichiers (pas les photos)"""
    user_id = event.sender_id
    
    # Nettoyer les anciennes sessions
    await clean_old_sessions()
    
    file = event.file
    
    # V√©rifier la taille du fichier
    if file.size > MAX_FILE_SIZE:
        await event.reply(
            "‚ùå <b>File too large!</b>\n\n"
            "Maximum size: {}\n"
            "Your file: {}".format(
                human_readable_size(MAX_FILE_SIZE),
                human_readable_size(file.size)
            ),
            parse_mode='html'
        )
        return
    
    # V√©rifier les limites de l'utilisateur
    limit_ok, limit_message = check_user_limits(user_id, file.size)
    if not limit_ok:
        await event.reply(
            "‚ö†Ô∏è <b>Usage Limit Reached!</b>\n\n{}\n\nUse /usage to check your limits.".format(limit_message),
            parse_mode='html'
        )
        return
    
    # Obtenir les informations du fichier
    file_name = file.name or "unnamed_file"
    file_size = human_readable_size(file.size)
    extension = os.path.splitext(file_name)[1] or ""
    mime_type = file.mime_type or "unknown"
    
    # V√©rifier si c'est une vid√©o
    is_video = mime_type.startswith('video/') or extension.lower() in ['.mp4', '.mkv', '.webm', '.avi', '.mov', '.flv']
    
    # Stocker les informations de session
    user_sessions[user_id] = {
        'message': event.message,
        'file_name': file_name,
        'timestamp': datetime.now(),
        'action': None,
        'is_video': is_video,
        'file_size': file.size  # Stocker la taille pour la mise √† jour de l'utilisation
    }
    
    # Cr√©er les boutons
    buttons = [
        [Button.inline("üñºÔ∏è Add Thumbnail", f"add_thumb_{user_id}")],
        [Button.inline("‚úèÔ∏è Rename Only", f"rename_only_{user_id}")],
        [Button.inline("‚ùå Cancel", f"cancel_{user_id}")]
    ]
    
    # Obtenir les informations d'utilisation pour l'affichage
    usage_info = get_user_usage_info(user_id)
    
    info_text = """üìÅ <b>FILE INFORMATION</b>

‚óÜ <b>Name:</b> <code>{}</code>
‚óÜ <b>Size:</b> {}
‚óÜ <b>Type:</b> {} {}
‚óÜ <b>Extension:</b> {}

üìä <b>Your Usage:</b> {} / {} ({:.1f}%)

‚ùì <b>What do you want to do?</b>""".format(
        file_name,
        file_size,
        mime_type,
        "üé¨ (Video)" if is_video else "",
        extension,
        human_readable_size(usage_info['daily_used']),
        human_readable_size(usage_info['daily_limit']),
        usage_info['percentage']
    )
    
    await event.reply(
        info_text, 
        parse_mode='html',
        buttons=buttons
    )

@bot.on(events.CallbackQuery)
async def callback_handler(event):
    """Handler optimis√© pour les boutons inline"""
    data = event.data.decode('utf-8')
    user_id = event.query.user_id
    
    # Settings menu
    if data == "show_settings":
        await show_settings_menu(event)
        return
    
    # Add custom text
    elif data == "add_custom_text":
        if user_id not in sessions:
            sessions[user_id] = {}
        sessions[user_id]['awaiting_custom_text'] = True
        
        current_text = sessions[user_id].get('custom_text', '')
        
        message = "üìù <b>Add Custom Text</b>\n\n"
        if current_text:
            message += f"Current: <code>{current_text}</code>\n\n"
        
        message += """Send me the text to add to all filenames.

Examples:
‚Ä¢ <code>@mychannel</code>
‚Ä¢ <code>2024</code>
‚Ä¢ <code>[Premium]</code>
‚Ä¢ <code>MyCollection</code>

Send /cancel to abort."""
        
        await event.edit(message, parse_mode='html')
        return
    
    # Change text position
    elif data == "change_text_position":
        current_pos = sessions.get(user_id, {}).get('text_position', 'end')
        
        keyboard = [
            [Button.inline("üìç At Start" + (" ‚úì" if current_pos == 'start' else ""), "set_position_start")],
            [Button.inline("üìç At End" + (" ‚úì" if current_pos == 'end' else ""), "set_position_end")],
            [Button.inline("üîô Back", "show_settings")]
        ]
        
        await event.edit(
            "üìç <b>Text Position</b>\n\n"
            f"Current: <b>{current_pos.capitalize()}</b>\n\n"
            "Examples:\n"
            "‚Ä¢ Start: <code>@channel Document.pdf</code>\n"
            "‚Ä¢ End: <code>Document @channel.pdf</code>",
            parse_mode='html',
            buttons=keyboard
        )
        return
    
    # Set position
    elif data.startswith("set_position_"):
        position = data.replace("set_position_", "")
        if user_id not in sessions:
            sessions[user_id] = {}
        sessions[user_id]['text_position'] = position
        save_user_preferences()
        
        await event.answer(f"‚úÖ Position set to {position}")
        await show_settings_menu(event)
        return
    
    # Remove custom text
    elif data == "remove_custom_text":
        if user_id in sessions and 'custom_text' in sessions[user_id]:
            old_text = sessions[user_id]['custom_text']
            del sessions[user_id]['custom_text']
            save_user_preferences()
            
            await event.edit(
                f"‚úÖ <b>Custom text removed!</b>\n\n"
                f"Deleted: <code>{old_text}</code>",
                parse_mode='html'
            )
            await asyncio.sleep(2)
            await show_settings_menu(event)
        else:
            await event.answer("‚ùå No custom text to remove", alert=True)
        return
    
    # Toggle clean tags
    elif data == "toggle_clean_tags":
        if user_id not in sessions:
            sessions[user_id] = {}
        current = sessions[user_id].get('clean_tags', True)
        sessions[user_id]['clean_tags'] = not current
        save_user_preferences()
        
        status = "enabled" if not current else "disabled"
        await event.answer(f"‚úÖ Auto-clean {status}")
        await show_settings_menu(event)
        return
    
    # Close settings
    elif data == "close_settings":
        await event.delete()
        return
    
    # Add/Edit Username
    elif data == "add_custom_username":
        if user_id not in sessions:
            sessions[user_id] = {}
        sessions[user_id]['awaiting_custom_username'] = True
        current_username = sessions[user_id].get('custom_username', '')
        message = "üë§ <b>Add/Edit Username</b>\n\n"
        if current_username:
            message += f"Current: <code>{current_username}</code>\n\n"
        message += "Send me the username to add to all filenames (e.g. <code>@monchannel</code>).\n\nSend /cancel to abort."
        await event.edit(message, parse_mode='html')
        return
    
    if data.startswith('cancel_'):
        clicked_user_id = int(data.split('_')[1])
        if clicked_user_id == user_id and user_id in user_sessions:
            if 'temp_path' in user_sessions[user_id]:
                try:
                    os.remove(user_sessions[user_id]['temp_path'])
                except:
                    pass
            del user_sessions[user_id]
            await event.edit("‚ùå <b>Operation cancelled.</b>", parse_mode='html')
        else:
            await event.answer("‚ùå You can't cancel this operation.", alert=True)

    elif data.startswith('add_thumb_'):
        clicked_user_id = int(data.split('_')[2])
        if clicked_user_id == user_id and user_id in user_sessions:
            thumb_path = os.path.join(THUMBNAIL_DIR, f"{user_id}.jpg")
            if not os.path.exists(thumb_path):
                await event.answer("‚ùå No thumbnail set! Use /setthumb first.", alert=True)
                return
            
            try:
                # ‚ö° UPLOAD RAPIDE AVEC THUMBNAIL INT√âGR√â
                await event.edit("‚ö° <b>Processing with thumbnail...</b>", parse_mode='html')
                
                original_msg = user_sessions[user_id]['message']
                file_name = user_sessions[user_id]['file_name']
                file_size = user_sessions[user_id]['file_size']
                is_video = user_sessions[user_id].get('is_video', False)
                
                # Appliquer les modifications de nom si configur√©es
                clean_tags = sessions.get(user_id, {}).get('clean_tags', True)
                if clean_tags:
                    file_name = clean_filename_text(file_name)
                
                custom_text = sessions.get(user_id, {}).get('custom_text', '')
                text_position = sessions.get(user_id, {}).get('text_position', 'end')
                
                if custom_text:
                    file_name = add_custom_text_to_filename(file_name, custom_text, text_position)
                
                custom_username = sessions.get(user_id, {}).get('custom_username', '')
                if custom_username:
                    file_name = add_custom_text_to_filename(file_name, custom_username, text_position)
                
                sanitized_name = sanitize_filename(file_name)
                
                # Cr√©er un fichier temporaire pour le traitement
                temp_filename = f"{user_id}_{int(time.time())}_{uuid.uuid4().hex[:8]}"
                temp_path = os.path.join(TEMP_DIR, temp_filename)
                
                # T√©l√©charger le fichier avec progression
                await event.edit("‚¨áÔ∏è <b>Downloading...</b>", parse_mode='html')
                
                start_time = time.time()
                last_update_time = [start_time]
                
                async def download_progress(current, total):
                    now = time.time()
                    if now - last_update_time[0] < 3:  # Update toutes les 3 secondes
                        return
                    last_update_time[0] = now
                    
                    percentage = current * 100 / total
                    speed = current / (now - start_time)
                    eta = int((total - current) / speed) if speed > 0 else 0
                    
                    try:
                        await event.edit(
                            f"‚¨áÔ∏è <b>Downloading...</b>\n\n"
                            f"Progress: {percentage:.1f}%\n"
                            f"Speed: {human_readable_size(speed)}/s\n"
                            f"ETA: {eta}s",
                            parse_mode='html'
                        )
                    except:
                        pass
                
                path = await original_msg.download_media(
                    file=temp_path,
                    progress_callback=download_progress
                )
                
                if not path or not os.path.exists(path):
                    raise Exception("Failed to download file")
                
                if path != temp_path:
                    shutil.move(path, temp_path)
                
                # Pour les vid√©os, int√©grer le thumbnail avec FFmpeg
                if is_video and shutil.which("ffmpeg"):
                    await event.edit("üé¨ <b>Adding thumbnail to video...</b>", parse_mode='html')
                    
                    output_path = temp_path + "_with_thumb.mp4"
                    
                    # Commande FFmpeg pour ajouter le thumbnail
                    cmd = [
                        'ffmpeg', '-i', temp_path,
                        '-i', thumb_path,
                        '-map', '0:v', '-map', '0:a',
                        '-map', '1:v', '-c', 'copy',
                        '-c:v:1', 'mjpeg', '-disposition:v:1', 'attached_pic',
                        output_path,
                        '-hide_banner', '-loglevel', 'error'
                    ]
                    
                    process = await asyncio.create_subprocess_exec(
                        *cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    stdout, stderr = await process.communicate()
                    
                    if process.returncode == 0:
                        # Remplacer le fichier original par celui avec thumbnail
                        os.remove(temp_path)
                        temp_path = output_path
                    else:
                        logging.error(f"FFmpeg failed: {stderr.decode()}")
                        # Continuer sans thumbnail int√©gr√©
                
                # Pour les autres types de fichiers, utiliser le thumbnail comme preview
                # (Le thumbnail sera visible dans Telegram mais pas int√©gr√© dans le fichier)
                elif not is_video:
                    await event.edit("üìÑ <b>Processing document with thumbnail...</b>", parse_mode='html')
                
                # Upload du fichier avec thumbnail int√©gr√©
                await event.edit("üì§ <b>Uploading with thumbnail...</b>", parse_mode='html')
                
                # R√©cup√©rer les attributs vid√©o si c'est une vid√©o
                video_attributes = []
                if is_video:
                    duration = get_video_duration(temp_path)
                    width, height = get_video_dimensions(temp_path)
                    
                    if duration or (width and height):
                        video_attr = DocumentAttributeVideo(
                            duration=duration or 0,
                            w=width or 0,
                            h=height or 0,
                            supports_streaming=True
                        )
                        video_attributes.append(video_attr)
                
                # Attributs du fichier
                file_attributes = [DocumentAttributeFilename(sanitized_name)]
                if video_attributes:
                    file_attributes.extend(video_attributes)
                
                # Upload avec thumbnail int√©gr√© ou preview
                thumb_to_use = None
                if not is_video:
                    # Pour les documents, utiliser le thumbnail comme preview
                    thumb_to_use = thumb_path
                
                await bot.send_file(
                    event.chat_id,
                    temp_path,
                    caption="",
                    parse_mode='html',
                    file_name=sanitized_name,
                    thumb=thumb_to_use,  # Thumbnail pour preview (documents)
                    supports_streaming=is_video,
                    attributes=file_attributes
                )
                
                # Mise √† jour de l'utilisation
                update_user_usage(user_id, file_size)
                
                # Nettoyage
                try:
                    os.remove(temp_path)
                except:
                    pass
                
                await event.delete()
                del user_sessions[user_id]
                
            except Exception as e:
                await event.edit(f"‚ùå <b>Error:</b> {str(e)}", parse_mode='html')
                # Nettoyage en cas d'erreur
                try:
                    if 'temp_path' in locals() and os.path.exists(temp_path):
                        os.remove(temp_path)
                except:
                    pass
        else:
            await event.answer("‚ùå This is not for you or session expired.", alert=True)
            
    elif data.startswith('rename_only_'):
        clicked_user_id = int(data.split('_')[2])
        if clicked_user_id == user_id and user_id in user_sessions:
            user_sessions[user_id]['action'] = 'rename_only'
            ask_msg = await event.edit(
                "‚úèÔ∏è **Please send me the new filename** (including extension).",
                buttons=Button.inline("‚ùå Cancel", f"cancel_{user_id}")
            )
            # Store message ID to ensure user replies to the correct message
            user_sessions[user_id]['reply_id'] = ask_msg.id
        else:
            await event.answer("‚ùå This is not for you or the session has expired.", alert=True)

    elif data == 'help':
        # Message d'aide d√©taill√©
        help_text = """üìö <b>How to use this bot:</b>

1Ô∏è‚É£ Send me any file (document, video, audio)
2Ô∏è‚É£ Choose an action: 'Add Thumbnail' or 'Rename Only'.
3Ô∏è‚É£ **For Renaming:** Reply with the new filename (including extension).
4Ô∏è‚É£ **For Thumbnail:** Make sure you have set a thumbnail with /setthumb.

<b>üí° Tips:</b>
‚Ä¢ Use descriptive filenames
‚Ä¢ Keep the correct extension
‚Ä¢ Avoid special characters like / \ : * ? " < > |
‚Ä¢ Maximum file size: 2 GB

<b>‚ö° Commands:</b>
/start - Show welcome message
/cancel - Cancel current operation
/status - Check bot status"""
        
        await event.respond(help_text, parse_mode='html')
        await event.answer("‚ÑπÔ∏è Help sent!")  # Petite notification

@bot.on(events.NewMessage(func=lambda e: e.text and e.is_private and not e.text.startswith('/')))
async def text_handler(event):
    """Handler pour les messages texte"""
    user_id = event.sender_id
    
    if user_id not in sessions:
        return
    
    # Si on attend un texte personnalis√©
    if sessions[user_id].get('awaiting_custom_text'):
        custom_text = event.text.strip()
        
        if len(custom_text) > 50:
            await event.reply("‚ùå Text too long! Maximum 50 characters.")
            return
        
        # Sauvegarder le texte
        sessions[user_id]['custom_text'] = custom_text
        sessions[user_id]['awaiting_custom_text'] = False
        
        # Position par d√©faut
        if 'text_position' not in sessions[user_id]:
            sessions[user_id]['text_position'] = 'end'
        
        save_user_preferences()
        
        await event.reply(
            f"‚úÖ <b>Custom text saved!</b>\n\n"
            f"Text: <code>{custom_text}</code>\n"
            f"Position: {sessions[user_id]['text_position']}\n\n"
            f"This will be added to all renamed files.",
            parse_mode='html'
        )
        return
    # Si on attend un username personnalis√©
    if sessions[user_id].get('awaiting_custom_username'):
        username = event.text.strip()
        if not username.startswith('@') or len(username) > 64:
            await event.reply("‚ùå Username must start with @ and be shorter than 64 characters.")
            return
        sessions[user_id]['custom_username'] = username
        sessions[user_id]['awaiting_custom_username'] = False
        save_user_preferences()
        await event.reply(
            f"‚úÖ <b>Username saved!</b>\n\n"
            f"Username: <code>{username}</code>\n"
            f"This will be added to all renamed files.",
            parse_mode='html'
        )
        return

@bot.on(events.NewMessage(func=lambda e: e.is_reply))
async def rename_handler(event):
    """Handler pour renommer les fichiers"""
    user_id = event.sender_id
    
    # V√©rifier si c'est une r√©ponse valide et si l'action est 'rename_only'
    if user_id not in user_sessions or user_sessions[user_id].get('action') != 'rename_only':
        return
    
    # Nettoyer les anciennes sessions
    await clean_old_sessions()
    
    # V√©rifier si la session n'a pas expir√©
    if user_id not in user_sessions:
        await event.reply("‚è± Session expired. Please send the file again.")
        return
    
    reply_to = await event.get_reply_message()
    # Ensure the user is replying to the "send me new name" message
    if reply_to.id != user_sessions[user_id].get('reply_id'):
        return
    
    new_name = event.text.strip()
    
    # Valider le nouveau nom
    if not new_name:
        await event.reply("‚ùå Please provide a valid filename.")
        return
    
    if "." not in new_name and "." in user_sessions[user_id]['file_name']:
        # Ajouter l'extension originale si oubli√©e
        original_ext = os.path.splitext(user_sessions[user_id]['file_name'])[1]
        new_name += original_ext
        await event.reply("‚ÑπÔ∏è Extension added automatically: <code>{}</code>".format(new_name), parse_mode='html')

    # Lancer le traitement du fichier pour le renommage sans miniature
    await process_file(event, user_id, new_name=new_name, use_thumb=False)

async def process_file(event, user_id, new_name=None, use_thumb=False):
    """Fonction g√©n√©rique pour traiter (t√©l√©charger et uploader) un fichier."""
    
    if user_id not in user_sessions:
        # Session might have expired or been cancelled
        return

    progress_msg = None
    reencoded_path = None
    temp_path = None

    try:
        if new_name is None:
            new_name = user_sessions[user_id]['file_name']
        
        sanitized_name = sanitize_filename(new_name)
        # Ajout du custom text si pr√©sent
        custom_text = sessions.get(user_id, {}).get('custom_text', '')
        text_position = sessions.get(user_id, {}).get('text_position', 'end')
        if custom_text:
            sanitized_name = add_custom_text_to_filename(sanitized_name, custom_text, text_position)
        # Ajout du username custom si pr√©sent
        custom_username = sessions.get(user_id, {}).get('custom_username', '')
        if custom_username:
            sanitized_name = add_custom_text_to_filename(sanitized_name, custom_username, text_position)
        
        # Message de progression
        if isinstance(event, events.CallbackQuery.Event):
             progress_msg = await event.edit("‚è≥ <b>Processing...</b>", parse_mode='html')
        else:
             progress_msg = await event.reply("‚è≥ <b>Processing...</b>", parse_mode='html')

        await bot(SetTypingRequest(
            event.chat_id, 
            SendMessageUploadDocumentAction(progress=0)
        ))
        
        original_msg = user_sessions[user_id]['message']
        is_video = user_sessions[user_id].get('is_video', False)
        
        temp_filename = "{}_{}_{}".format(user_id, int(time.time()), uuid.uuid4().hex[:8])
        temp_path = os.path.join(TEMP_DIR, temp_filename)
        user_sessions[user_id]['temp_path'] = temp_path
        
        start_time = time.time()
        last_update_time = [start_time]
        
        async def download_progress(current, total):
            await progress_callback(current, total, event, start_time, progress_msg, "Downloading", last_update_time)
        
        path = await original_msg.download_media(
            file=temp_path,
            progress_callback=download_progress
        )
        
        if not path or not os.path.exists(path):
            raise Exception("Failed to download file")
        
        if path != temp_path:
            shutil.move(path, temp_path)
        
        upload_path = temp_path
        
        # R√©cup√©rer les attributs vid√©o si c'est une vid√©o
        video_attributes = []
        if is_video:
            duration = get_video_duration(temp_path)
            width, height = get_video_dimensions(temp_path)
            
            if duration or (width and height):
                video_attr = DocumentAttributeVideo(
                    duration=duration or 0,
                    w=width or 0,
                    h=height or 0,
                    supports_streaming=True
                )
                video_attributes.append(video_attr)
        
        # SKIP FFmpeg - pas n√©cessaire pour renommage simple
        # Optimisation d√©sactiv√©e pour am√©liorer les performances
        
        await progress_msg.edit("üì§ <b>Uploading file...</b>", parse_mode='html')
        
        start_time = time.time()
        last_update_time_upload = [start_time]
        
        async def upload_progress(current, total):
            await progress_callback(current, total, event, start_time, progress_msg, "Uploading", last_update_time_upload)
        
        thumb_to_use = None
        if use_thumb:
            thumb_path = os.path.join(THUMBNAIL_DIR, "{}.jpg".format(user_id))
            if os.path.exists(thumb_path):
                thumb_to_use = thumb_path
        
        # Ajouter l'attribut filename
        file_attributes = [DocumentAttributeFilename(sanitized_name)]
        
        # Ajouter les attributs vid√©o si disponibles
        if video_attributes:
            file_attributes.extend(video_attributes)
        
        # Envoyer le fichier avec tous les attributs n√©cessaires
        await event.client.send_file(
            event.chat_id,
            upload_path,
            caption="",  # Caption vide
            file_name=sanitized_name,
            thumb=thumb_to_use,
            supports_streaming=is_video,  # Active le streaming pour les vid√©os
            attributes=file_attributes,    # Inclut tous les attributs n√©cessaires
            force_document=False,          # Permet √† Telegram de d√©tecter le type
            progress_callback=upload_progress,
            part_size_kb=512  # Chunks optimis√©s pour de meilleures performances
        )
        
        await progress_msg.delete()
        
        # Mettre √† jour l'utilisation de l'utilisateur apr√®s un traitement r√©ussi
        if user_id in user_sessions and 'file_size' in user_sessions[user_id]:
            update_user_usage(user_id, user_sessions[user_id]['file_size'])
            logging.info(f"Usage updated for user {user_id}: +{human_readable_size(user_sessions[user_id]['file_size'])}")
        
    except FloodWaitError as e:
        if progress_msg:
             await progress_msg.edit("‚è≥ Rate limit hit. Please wait {} seconds.".format(e.seconds))
        else:
            await event.reply("‚è≥ Rate limit hit. Please wait {} seconds.".format(e.seconds))
    except Exception as e:
        error_msg = "‚ùå <b>Error:</b> {}\n\nPlease try again.".format(str(e))
        if progress_msg:
            await progress_msg.edit(error_msg, parse_mode='html')
        else:
            await event.reply(error_msg, parse_mode='html')
        
    finally:
        # Nettoyage am√©lior√©
        if temp_path and os.path.exists(temp_path):
            try:
                os.remove(temp_path)
            except OSError as e:
                logging.error(f"Error deleting temp_path {temp_path}: {e}")
        
        if reencoded_path and os.path.exists(reencoded_path):
            try:
                os.remove(reencoded_path)
            except OSError as e:
                logging.error(f"Error deleting reencoded_path {reencoded_path}: {e}")

        if user_id in user_sessions:
            del user_sessions[user_id]

def main():
    """Fonction principale modifi√©e"""
    print("ü§ñ Bot started successfully!")
    print("üìÅ Temp directory: {}".format(TEMP_DIR))
    print("üìä Max file size: {}".format(human_readable_size(MAX_FILE_SIZE)))
    print("üé¨ FFmpeg: {}".format("Available" if shutil.which("ffmpeg") else "Not available"))
    print("üìà Daily limit: {} per user".format(human_readable_size(DAILY_LIMIT_BYTES)))
    print("‚è± Cooldown: {} seconds between files".format(COOLDOWN_SECONDS))
    print("‚ö° Fast thumbnail mode: ENABLED")
    
    # Charger les donn√©es
    load_user_usage()
    load_user_preferences()
    print("üìä User data loaded")
    
    # Envoyer un message aux admins si configur√©
    async def notify_admins():
        if ADMIN_IDS:
            admin_list = [int(x) for x in str(ADMIN_IDS).split(',') if x.strip()]
            for admin_id in admin_list:
                try:
                    await bot.send_message(
                        admin_id, 
                        "üü¢ <b>Bot started!</b>\n\nRename bot is now online and ready.\n\nüìà Daily limit: {}\n‚è± Cooldown: {}s\n‚ö° Fast mode: ENABLED".format(
                            human_readable_size(DAILY_LIMIT_BYTES),
                            COOLDOWN_SECONDS
                        ),
                        parse_mode='html'
                    )
                except:
                    pass
    
    # D√©marrer la t√¢che de nettoyage automatique
    async def start_cleanup():
        await auto_cleanup_task()
    
    # Notifier les admins et d√©marrer le nettoyage
    bot.loop.run_until_complete(notify_admins())
    bot.loop.create_task(start_cleanup())
    
    # D√©marrer le bot
    print("\n‚úÖ Bot is running! Press Ctrl+C to stop.\n")
    bot.run_until_disconnected()

if __name__ == '__main__':
    main()